# 编程教育平台的问题（持续更新）

### 总体思路：

- 本程序的参考网站有国外的同类产品：scratch；国内的同类产品编程猫
- 本程序的积木块的实现是用svg矢量图进行实现。用矢量图进行实现的原因有两个，一个是矢量图在页面是通过标记语言进行显示的，进行积木块的嵌套比较容易，代码块的嵌套来对应逻辑的嵌套，会比较符合开发思路。而如果用图片的话，没办法做到嵌套，所以只能用svg矢量图，用canvas的难度比较大。
- 用鼠标的事件：mousedown、mousemove、mouseup来实现。在鼠标mousedown的时候，确定点击的是哪一个svg块

****

### 积木块的总体介绍

- 积木块使用svg来显示说明的，svg矢量图的有点很多，就不一一列举了，但是svg很适合本项目。
- 本项目中，在编码模式中的所有的积木块的信息存储在一个全局的变量中，这个变量是this.$store.state.canvaList，是一个对象，内嵌7种积木块，每个积木块都对应这个对象的一个属性，这个对象的每种属性都是一个数组，数组的每个元素则是对应在画布上的积木，每个元素都有基本的属性（宽高、x坐标、y坐标，id，value等），都代表积木块。要注意到的是，如果这个元素是circle的话，则会有另外一个属性，contain，这个contain则是包含了另外一个对象，这个对象的格式和canvasList对象的格式相同，这样就形成了层层嵌套的效果。
- 每个元素的id是独一无二的，在产生这个积木块的时候就定好了，然后id号是el + this.$store.state.count，而这个count元素会递增，从而实现每个积木块的id是独一无二的。
- 在svg的画布上对积木块的操作，最后面都会更新这个全局的canvasList对象，更新每个积木块的状态。所有的状态都是在这里更新的，而我们只是对全局变量进行更新，然后积木块则是监听这个全局变量做出反应，我们并不会对dom节点进行任何操作。只对canvasList进行操作，这样可以简化整个项目的操作：只关注数据，不关注页面节点。

****

### 如何做到无限嵌套

在utils方法中，shared中有一个model.js，里面存储着当前的逻辑语句积木块的数组，并且有一个初始化方法。这个方法的代码如下：

```js
export const svgComponentOption = [
  'condition',
  'order',
  'assist',
  'noRefFunc',
  'refFunc',
  'circle',
  'judge',
]

export function componentListMixin(conObj) {
  // 这个的作用是进行遍历数组创建属性，在执行的时候是分为多个函数进行执行，并不是同步操作，会在事件循环中添加事件。如果在事件循环结束前对这个对象进行修改，可能造成一些不可预知的错误
  svgComponentOption.forEach((value) => {
    conObj[value] = [];
  });
}

export function listPush(list, type, item) {
  if (type == 'circle' || type == 'judge') {
    // 如果是判断语句或者选择语句，需要特殊照顾
    item.contain = [];
    item.hasCdn = false;
    list[type].push(item);
  } else {
    list[type].push(item)
  }
  // 更新后有时候视图层来不及更新，这个的作用那个是作为强制视图层进行更新，后面会介绍到
  this.$store.state.isRenew = !this.$store.state.isRenew;
}

```

在初始化页面的时候，先对canvasList进行初始化。大概初始化结果如下：

![](http://47.102.136.151:4000//education/edu-data.png)

初始化后，大概是上面这个样子，有人会问如何实现嵌套呢？！

先来分析一下在哪里需要嵌套：circle、judge类型需要嵌套。那只需要在circle和judge元素中增加一个属性contain，这个属性进行嵌套。而我的做法如下：

- 每次circle属性数组中增加一个元素时候，vue对象察觉到这个数组有东西进行来了，用for循环的列表渲染，而vueComponent会有一个生命周期，在生命周期的初始，即渲染完毕的时候进行添加circle和judge的contain属性，并且在这个属性中进行初始化，这样每次创建circle、judge的时候会进行添加。具体如下图：

![](http://47.102.136.151:4000//education/nest-data.png)

在mounted函数中，这个componentListMixin方法则是对这个containObject进行增加。（这个containObject就是相应的circle或者judge所指向的数组中的元素，是canvasList里面的东西，作为参数传到这个component中）。而为什么还要有个component中的data呢？！这是因为在circle创建的时候，我们并不会对contain属性进行赋值，如果直接引用containObject，会发生错误，没法访问undefined的属性，所以只能曲线救国。

****

### 拖拽的实现：

与网上的一般块级元素的拖拽思路一致。**所有的积木块的所有信息（宽高、x坐标、y坐标等）存放于一个全局变量，这个变量同时存在嵌套（判断语句和循环语句中可以嵌套）的对象，这个内部嵌套对象的形式跟整个全局变量格式一致。**

- 获得鼠标左键按下的时候点击的积木块对象（event.target）进行获取，并且获取鼠标在屏幕的坐标。进行存储
- 鼠标移动的时候，不断获取鼠标在屏幕的坐标。并且计算出相对于鼠标按下时候的相对位置，将增量添加至积木块目标的transform值的增量上去（这个积木块的初始的transform值是有确定的值）。
- 鼠标松开的时候，判断鼠标指向的积木块是否与页面上的块碰撞了/是否是从内嵌块拖出来。进行相应的操作后更新这个对象。

****

### 了解并且利用事件循环

如果你并不了解事件循环，那么麻烦先去看看JavaScript中的事件循环是什么再来看吧。

由于JavaScript是单线程，存在着很多的异步操作，比如说对数据进行改变，这个数据改变并不是简单的数据赋值这样同步的方式，很大可能赋值的时候是异步操作。所以执行的时候很可能会比较晚执行，但是始终会在本次事件循环结束前完成，那么我要怎么进行立即读取呢？我们肯定是要读取更新后的值，那么要利用setTimeout进行下次事件循环时候读取。很多地方用到setTimeout，要理解是因为事件循环不得不用。

****

### 嵌套如何实现

我在这里讲一下一个元素从点击到嵌套时候系统的动作分解：

- 拖拽
- 判断是否碰撞
- 将父容器改变
- 嵌入

拖拽前面已经讲过了，我就不累赘讲述了。讲一下是否碰撞，我们的页面中的积木块全都存放在canvasList，里面具有所有积木块的信息，宽高和坐标，通过宽高和坐标，通过碰撞算法进行判断是否碰撞。这个不需要怎么介绍。我想介绍的是父容器的改变：

- 要先返回到头部说为什么一定要用到svg图，除了它是标记语言，能够实现嵌套之外，主要是这个svg图是用代码来实现的，所以可能动态改这个svg图的大小，颜色等。父容器的改变要先改变长度，让父容器能够装下这个子容器，所有容器都是svg的标签path来实现的，所以需要改变path标签的d属性，这个可以去百度一下怎么改，这个难度在于如何找到改哪个东西从而实现想要的效果，这个改变是固定的，所以我放到一个option.js，放到util文件夹中，是一个常量。我放一张图吧，看看就行，不用太在意。

![](http://47.102.136.151:4000//education/container-options.png)

嵌入：

- 改变想要内嵌元素的坐标，这个的话，也是通过试验完成的，这个的话，也是直接在canvasList中寻找并且进行修改就可以了。我是drag.js进行修改的，只要进去看一下就行了。

****

### 渲染问题



****

### 递归调用模板问题

Vue中是允许import本模板的。并且能够通过console.log打印出来。于是我一开始的想法就是在嵌套结构中引入本模板，想要以此来实现嵌套结构。例子如下，以下是circle为例：

![](http://47.102.136.151:4000//education/edu-circle.png)

上面这个文件是circle文件，引入的是本文件。（这里是改过了，原本是引入本模板）。这样控制台输出也正常，也不会报错，但是渲染就是渲染不出来（没办法解析）。这个其实很奇怪。后来发现是vue不允许一级引用本模板，想一下如果可以引用本模板。如果是直接渲染而不是像我这样循环渲染的话，那么会出现无限循环嵌套的问题。虽然vue避免这个，但是也不会进行提示报错等信息，只是不会渲染出来。

后来仔细想了下这个问题，想出一个办法，就是用一个完全一样的代码，作为另外一个模板，然后相互引用，从而解决了这个问题。具体的项目目录如下：

![](http://47.102.136.151:4000//education/1.png)

